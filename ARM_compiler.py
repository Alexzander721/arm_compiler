"""
/***************************************************************************
 Compiler
                                 A QGIS plugin
 Собирает слои для АРМ
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-06-22
        copyright            : (C) 2021 by Travin Alexzander/Roslesinforg
        email                : travin1995@inbox.ru
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox
import processing
import os
from qgis.core import (QgsApplication,
                       QgsProject,
                       QgsCoordinateReferenceSystem,
                       QgsCoordinateTransform,
                       QgsField,
                       QgsFields,
                       QgsFeature,
                       QgsVectorDataProvider,
                       QgsVectorLayer,
                       QgsVectorFileWriter,
                       QgsWkbTypes,
                       QgsVectorLayerUtils,
                       QgsMapLayerType,
                       QgsMapLayer,
                       )

from .resources import *
from .ARM_compiler_dialog import CompilerDialog


class Compiler:

    def __init__(self, iface):
        self.iface = iface
        self.instance = QgsProject.instance()
        self.plugin_dir = os.path.dirname(__file__)

        self.actions = []
        self.menu = self.tr(u'&ARM compiler')

        self.first_start = None

    def tr(self, message):
        return QCoreApplication.translate('Compiler', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        icon_path = ':/plugins/ARM_compiler/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'ARM compiler'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&ARM compiler'),
                action)
            self.iface.removeToolBarIcon(action)

    def cipher(self, layer):
        """
        Растановка ID линейным объектам
        """
        if self.dlg.checkBox.isChecked():
            ciper = {'ГИДР': 27, 'РУЧЬИ': 28, 'РУЧЕЙ': 28, 'КАНАЛ': 29, 'ЖЕЛЕЗН': 30, 'ЖД': 30, 'АВТО': 31, 'ГРУНТ': 31,
                     'ЗИМНИК': 32, 'ТРОПА': 33, 'ТРОПЫ': 33, 'ЛЕСН': 33, 'ЛЕСО': 33, 'КАНАВ': 34, 'ГРАНИЦ': 35,
                     'ПРОСЕК': 36, 'ЛЭП': 45, 'ГАЗ': 46, 'ТЕЛЕФОН': 47, 'ЛИНИЯ': 47, 'СВЯЗЬ': 47, 'СВЯЗИ': 47,
                     'МЕЛИОРАЦ': 48, 'ПОЖАР': 49, 'ПРОЧИЕ': 50, 'ВОДОПРОВОД': 56, 'НЕФТ': 82}
        else:
            ciper = {'ГИДР': 52, 'РУЧЬИ': 54, 'РУЧЕЙ': 54, 'КАНАЛ': 54, 'ЖЕЛЕЗН': 55, 'ЖД': 55, 'АВТО': 57, 'ГРУНТ': 58,
                     'ЗИМНИК': 66, 'ТРОПА': 66, 'ТРОПЫ': 66, 'ЛЕСН': 66, 'ЛЕСО': 64, 'КАНАВ': 54, 'ЛЭП': 73,
                     'ТЕЛЕФОН': 71, 'ЛИНИЯ': 71, 'СВЯЗЬ': 71, 'СВЯЗИ': 71, 'ПРОЧИЕ': 59}
        if layer.type() == 0 and layer.wkbType() == 5:
            layer.dataProvider().addAttributes([QgsField("LineID", QVariant.Int)]), layer.updateFields()
            ilist = [ciper[i] for i in ciper.keys() if i in layer.name().upper()]
            layer.startEditing()
            try:
                [layer.dataProvider().changeAttributeValues(
                    {feature.id(): {layer.dataProvider().fieldNameIndex("LineID"): int(ilist[0])}}) for feature in
                    layer.getFeatures()]
            except IndexError:
                pass
            layer.commitChanges()

    def saveSHP(self, crsname, layer):
        """
        Сохранение слоёв в ESRI Shapefile с СК
        """
        if layer.type() == 0:
            error = QgsVectorFileWriter.writeAsVectorFormat(layer,
                                                            f"{self.dlg.lineEdit.text()}/{crsname}_" + layer.name(),
                                                            'utf-8',
                                                            QgsCoordinateTransform(layer.crs(),
                                                                                   self.dlg.mQgsProjectionSelectionWidget.crs(),
                                                                                   self.instance),
                                                            "ESRI Shapefile")
            if error[0] == QgsVectorFileWriter.NoError:
                pass

    def remove(self, crsname, layer):
        """
        Удаление слоёв MIF открытие сохранёных SHP файлов
        """
        if layer.type() == 0:
            self.instance.addMapLayer(
                QgsVectorLayer(f"{self.dlg.lineEdit.text()}/{crsname}_{layer.name()}.shp", f"{crsname}_{layer.name()}",
                               "ogr"))
            self.instance.removeMapLayer(layer)

    def dct(self):
        """
        Выбор каталога сохранения
        """
        self.dlg.lineEdit.setText(QFileDialog.getExistingDirectory())

    def polkw(self, slayername, crsname, layer):
        """
        Создание полигонов кварталов в СК
        """
        if layer.name() == f"{crsname}_{slayername}":
            processing.run(
                "native:dissolve",
                {'INPUT': layer,
                 'FIELD': self.dlg.comboBox2.currentText(),
                 'OUTPUT': f"{self.dlg.lineEdit.text()}/{crsname}_полигоны-квартала.shp"})
            self.instance.addMapLayer(
                QgsVectorLayer(f"{self.dlg.lineEdit.text()}/{crsname}_полигоны-квартала.shp",
                               f"{crsname}_полигоны-квартала",
                               "ogr"))

    def uline(self, crsname):
        """
        Объединение линейных слоёв в один
        """
        inputted = [layer.layer() for layer in self.instance.layerTreeRoot().children() if
                    layer.layer().type() == 0 and layer.layer().wkbType() == 5]
        processing.runAndLoadResults("qgis:mergevectorlayers",
                                     {'LAYERS': inputted,
                                      'OUTPUT': f'{self.dlg.lineEdit.text()}/{crsname}_LINES.shp'})

    def split(self, crsname):
        """
        Разбитие линейного слоя по атрибуту
        """
        if self.dlg.checkBox.isChecked():
            key = ['Гидрография', 'Ручей', 'Каналы', 'ЖД', 'Дороги', 'Зимник', 'Лесные_дор', 'Канавы', 'Границы',
                   'Просека', 'ЛЭП', 'ГАЗ', 'Линия_связи', 'Мелиорация', 'Пр-пожарные', 'Прочие_трассы', 'Водопровод',
                   'Нефтепровод']
            vlaue = [27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 45, 46, 47, 48, 49, 50, 56, 82]
        else:
            key = ['Гидрография', 'Ручей', 'Каналы', 'ЖД', 'Дороги', 'Дороги_грунт', 'Зимник', 'Лесные_дор', 'Канавы',
                   'ЛЭП', 'Прочие', 'Линия_связи']
            vlaue = [52, 54, 54, 55, 57, 58, 66, 66, 54, 73, 59, 71]
        layers = self.iface.mapCanvas().layers()
        slayer = self.dlg.comboBox_i.itemData(self.dlg.comboBox_i.currentIndex())
        if slayer.wkbType() == 5:
            selectedfield = self.dlg.comboBox2_i.currentText()
            findx = slayer.dataProvider().fieldNameIndex(f"{selectedfield}")
            processing.run("qgis:splitvectorlayer",
                           {'INPUT': slayer,
                            'FIELD': f'{selectedfield}',
                            'FILE_TYPE': 0,
                            'OUTPUT': f'{self.dlg.lineEdit.text()}'})
            for vl in list(set([feature.attributes()[findx] for feature in slayer.getFeatures()])):
                if vl in vlaue:
                    gpkglayer = QgsVectorLayer(f"{self.dlg.lineEdit.text()}/{selectedfield}_{vl}.gpkg",
                                               f"{key[vlaue.index(vl)]}",
                                               "ogr")
                    self.instance.addMapLayer(gpkglayer)
                    layers.append(gpkglayer)
            for layer in layers:
                if layer.type() == 0:
                    self.saveSHP(crsname, layer)
                    vlayer = QgsVectorLayer(f"{self.dlg.lineEdit.text()}/{crsname}_{layer.name()}.shp",
                                            f"{crsname}_{layer.name()}",
                                            "ogr")
                    self.instance.addMapLayer(vlayer)
                    self.instance.removeMapLayer(layer)
            self.dlg.close()
            self.message()
        else:
            error = QMessageBox()
            error.setWindowTitle("Ошибка!")
            error.setText(
                "Выбранный слой не линейный!")
            error.exec_()

    def set_crs(self, layer):
        """
        Установка для слоёв MIF СК проекта
        """
        layer.setCrs(self.instance.crs())

    def message(self):
        """
        Сообщение по завершении
        """
        msbox = QMessageBox()
        msbox.setIcon(QMessageBox.Information)
        msbox.setText(f"Результирующие слои сохранены: {self.dlg.lineEdit.text()}")
        msbox.setWindowTitle("Готово!")
        msbox.exec()

    def apply(self):
        """
        Запуск алгоритмов обработки, проверка на ошибки
        """
        cname = format(self.dlg.mQgsProjectionSelectionWidget.crs().description())
        cname = cname.replace(" ", "").replace("/", "-")
        slayername = self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex()).name()
        if not bool(self.dlg.lineEdit.text()):
            error_msg = QMessageBox()
            error_msg.setWindowTitle("Ошибка!")
            error_msg.setText(
                "Папка назначения не задана!")
            error_msg.exec_()
        elif self.dlg.tabWidget.currentIndex() == 0:
            if self.dlg.comboBox.itemData(
                    self.dlg.comboBox.currentIndex()).wkbType() == 3 or \
                    self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex()).wkbType() == 6:
                for layer in self.iface.mapCanvas().layers():
                    if layer.type() == QgsMapLayer.VectorLayer:
                        self.set_crs(layer)
                        self.saveSHP(cname, layer)
                        self.remove(cname, layer)
                for layer in self.instance.mapLayers().values():
                    self.polkw(slayername, cname, layer)
                    self.cipher(layer)
                self.uline(cname)
                self.message()
                self.dlg.close()
            else:
                error_msg_2 = QMessageBox()
                error_msg_2.setWindowTitle("Ошибка!")
                error_msg_2.setText(
                    "Выбранный слой не полигональный!")
                error_msg_2.exec_()
        elif self.dlg.tabWidget.currentIndex() == 1:
            self.split(cname)

    def cancel(self):
        """
        Закрытие окна программы
        """
        self.dlg.close()

    def choice_layer(self):
        """
        Выбор слоя
        """
        self.dlg.comboBox.clear()
        self.dlg.comboBox_i.clear()
        for layer in self.instance.mapLayers().values():
            if layer.type() == QgsMapLayer.VectorLayer:
                self.dlg.comboBox.addItem(layer.name(), layer)
                self.dlg.comboBox_i.addItem(layer.name(), layer)

    def choice_field(self):
        """
        Выбор поля "Квартальности" пользователем
        """
        self.dlg.comboBox2.clear()
        if self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex()) is not None:
            [self.dlg.comboBox2.addItem(field.name()) for field in
             self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex()).fields()]

    def choice_field_i(self):
        """
        Выбор поля ID линейных пользователем
        """
        self.dlg.comboBox2_i.clear()
        if self.dlg.comboBox_i.itemData(self.dlg.comboBox_i.currentIndex()) is not None:
            [self.dlg.comboBox2_i.addItem(field.name()) for field in
             self.dlg.comboBox_i.itemData(self.dlg.comboBox_i.currentIndex()).fields()]

    def run(self):
        """
        Запуск основных процессов
        """
        self.dlg = CompilerDialog()
        self.dlg.lineEdit.clear()
        self.dlg.checkBox.setChecked(True)
        self.dlg.toolButton.clicked.connect(self.dct)
        self.dlg.OK.clicked.connect(self.apply)
        self.dlg.Cancel.clicked.connect(self.cancel)
        self.choice_layer()
        self.choice_field()
        self.choice_field_i()
        self.dlg.comboBox.currentIndexChanged.connect(self.choice_field)
        self.dlg.comboBox_i.currentIndexChanged.connect(self.choice_field_i)
        self.dlg.mQgsProjectionSelectionWidget.setCrs(self.instance.crs())
        self.dlg.tabWidget.setCurrentIndex(0)
        self.dlg.show()
        lst = [layer.type() for layer in self.instance.mapLayers().values() if layer.type() == QgsMapLayer.VectorLayer]
        if QgsMapLayerType.VectorLayer not in lst:
            error = QMessageBox()
            error.setWindowTitle("Ошибка!")
            error.setText('Проект не содержит векторных слоёв!\n'
                          "Добавьте слои в проект!")
            error.exec_()
